<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" href="/rogue-origin-apps/favicon.png">
  <meta name="theme-color" content="#141816">
  <title>SQDCP Board - Rogue Origin</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display:ital@0;1&family=JetBrains+Mono:wght@400;500;600;700&family=Outfit:wght@300;400;500;600;700&display=optional" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/@phosphor-icons/web@2.0.3/src/duotone/style.css">
  <link rel="stylesheet" href="../css/shared-base.css">

  <style>
    :root {
      --bg: #141816;
      --surface: #1a1f1d;
      --border: rgba(102, 137, 113, 0.15);
      --text: rgba(255, 255, 255, 0.9);
      --text-dim: rgba(255, 255, 255, 0.5);
      --accent: #668971;
      --font-ui: 'Outfit', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
      --font-display: 'DM Serif Display', serif;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-ui);
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 24px;
    }

    .header-section {
      text-align: center;
      margin-bottom: 32px;
      page-break-after: avoid;
    }

    .company-name {
      font-family: var(--font-display);
      font-size: 32px;
      letter-spacing: 2px;
      margin-bottom: 4px;
      color: var(--text);
    }

    .board-title {
      font-size: 18px;
      font-weight: 500;
      letter-spacing: 4px;
      color: var(--text-dim);
      margin-bottom: 16px;
    }

    .date-display {
      font-family: var(--font-mono);
      font-size: 14px;
      color: var(--accent);
      font-weight: 600;
    }

    .charts-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 24px;
      margin-bottom: 24px;
    }

    .chart-container {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 20px;
      page-break-inside: avoid;
    }

    .chart-container.full-width {
      grid-column: 1 / -1;
    }

    .chart-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--text);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .chart-canvas {
      width: 100%;
      height: 200px;
    }

    .loading {
      text-align: center;
      padding: 48px;
      color: var(--text-dim);
      font-family: var(--font-mono);
    }

    .error {
      background: rgba(220, 38, 38, 0.1);
      border: 1px solid rgba(220, 38, 38, 0.3);
      color: #fca5a5;
      padding: 16px;
      border-radius: 8px;
      margin: 24px 0;
      text-align: center;
      font-family: var(--font-mono);
      font-size: 14px;
    }

    .print-btn {
      position: fixed;
      top: 24px;
      right: 24px;
      background: var(--accent);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-family: var(--font-ui);
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s;
      z-index: 1000;
    }

    .print-btn:hover {
      background: #557a60;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 137, 113, 0.3);
    }

    @media print {
      @page {
        size: landscape;
        margin: 0.5in;
      }

      body {
        background: white;
        color: black;
      }

      .sidebar,
      .print-btn {
        display: none !important;
      }

      .main {
        margin-left: 0 !important;
      }

      .container {
        max-width: 100%;
        padding: 0;
      }

      .header-section {
        margin-bottom: 20px;
      }

      .company-name {
        color: black;
        font-size: 28px;
      }

      .board-title {
        color: #666;
        font-size: 16px;
      }

      .date-display {
        color: #333;
      }

      .charts-grid {
        gap: 16px;
      }

      .chart-container {
        background: white;
        border: 1px solid #ddd;
        padding: 16px;
        page-break-inside: avoid;
      }

      .chart-title {
        color: black;
        font-size: 12px;
      }

      .chart-canvas {
        height: 180px;
      }
    }

    @media screen and (max-width: 1024px) {
      .charts-grid {
        grid-template-columns: 1fr;
      }

      .chart-container.full-width {
        grid-column: 1;
      }
    }
  </style>
</head>
<body class="auth-required">
  <a href="#main-content" class="skip-link">Skip to main content</a>

  <!-- Sidebar -->
  <aside class="sidebar" id="sidebar" role="navigation" aria-label="Main navigation">
    <div class="sidebar-toggle" onclick="toggleSidebar()" role="button" tabindex="0" aria-label="Collapse sidebar">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 19l-7-7 7-7M18 19l-7-7 7-7"/></svg>
      <span class="sidebar-toggle-label">Collapse</span>
    </div>
    <div class="brand">
      <img src="/rogue-origin-apps/favicon.png" alt="Rogue Origin" width="32" height="32">
      <h1>Rogue Origin</h1>
    </div>
    <nav>
      <div class="nav-item" onclick="window.location.href='index.html'" role="button" tabindex="0"><span class="icon"><i class="ph-duotone ph-chart-pie-slice"></i></span><span>Dashboard</span></div>
      <div class="nav-item" onclick="window.location.href='kanban.html'" role="button" tabindex="0"><span class="icon"><i class="ph-duotone ph-package"></i></span><span>Supply Kanban</span></div>
      <div class="nav-item" onclick="window.location.href='scoreboard.html'" role="button" tabindex="0"><span class="icon"><i class="ph-duotone ph-gauge"></i></span><span>Scoreboard</span></div>
      <div class="nav-item" onclick="window.location.href='barcode.html'" role="button" tabindex="0"><span class="icon"><i class="ph-duotone ph-barcode"></i></span><span>Barcode Printer</span></div>
      <div class="nav-item" onclick="window.location.href='sop-manager.html'" role="button" tabindex="0"><span class="icon"><i class="ph-duotone ph-book-open-text"></i></span><span>SOP Manager</span></div>
      <div class="nav-item" onclick="window.location.href='orders.html'" role="button" tabindex="0"><span class="icon"><i class="ph-duotone ph-clipboard-text"></i></span><span>Orders</span></div>
      <div class="nav-item" onclick="window.location.href='consignment.html'" role="button" tabindex="0"><span class="icon"><i class="ph-duotone ph-handshake"></i></span><span>Consignment</span></div>
      <div class="nav-item" onclick="window.location.href='hourly-entry.html'" role="button" tabindex="0"><span class="icon"><i class="ph-duotone ph-user-gear"></i></span><span>Floor Manager</span></div>
      <div class="nav-item active" aria-current="page"><span class="icon"><i class="ph-duotone ph-chart-bar"></i></span><span>SQDCP Board</span></div>
    </nav>
    <div class="sidebar-footer">
      <div class="user-info">
        <div class="user-avatar">RO</div>
        <div>
          <div class="user-name">Rogue Origin</div>
          <div class="user-role">Administrator</div>
        </div>
      </div>
    </div>
  </aside>

  <!-- Main Content -->
  <main class="main" id="main-content">
    <button class="print-btn" onclick="window.print()">
      <i class="ph-duotone ph-printer"></i>
      Print Board
    </button>

    <div class="container">
      <div class="header-section">
        <div class="company-name">ROGUE ORIGIN</div>
        <div class="board-title">SQDCP BOARD</div>
        <div class="date-display" id="currentDate">Loading...</div>
      </div>

      <div id="loading" class="loading">
        <i class="ph-duotone ph-spinner" style="font-size: 32px; animation: spin 1s linear infinite;"></i>
        <div>Loading production data...</div>
      </div>

      <div id="error" class="error" style="display: none;"></div>

      <div id="chartsContainer" style="display: none;">
        <div class="charts-grid">
          <!-- Target vs Actual -->
          <div class="chart-container full-width">
            <div class="chart-title">Target vs Actual (lbs/day)</div>
            <canvas id="targetActualChart" class="chart-canvas"></canvas>
          </div>

          <!-- Units per Operator per Hour -->
          <div class="chart-container">
            <div class="chart-title">Units per Operator per Hour</div>
            <canvas id="operatorChart" class="chart-canvas"></canvas>
          </div>

          <!-- Units per Trimmer per Hour -->
          <div class="chart-container">
            <div class="chart-title">Units per Trimmer per Hour</div>
            <canvas id="trimmerChart" class="chart-canvas"></canvas>
          </div>

          <!-- Tops & Smalls per Day -->
          <div class="chart-container full-width">
            <div class="chart-title">Tops & Smalls per Day</div>
            <canvas id="topsSmallsChart" class="chart-canvas"></canvas>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script src="../js/shared-base.js"></script>
  <script>
    // Display current date
    const now = new Date();
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    document.getElementById('currentDate').textContent = now.toLocaleDateString('en-US', options);

    // Calculate date range (last 30 days)
    function getDateRange() {
      const end = new Date();
      const start = new Date();
      start.setDate(end.getDate() - 30);
      
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };

      return { start: formatDate(start), end: formatDate(end) };
    }

    // Fetch production data
    async function fetchProductionData() {
      try {
        const { start, end } = getDateRange();
        const url = `https://rogue-origin-api.roguefamilyfarms.workers.dev/api/production?action=dashboard&start=${start}&end=${end}`;
        
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Filter out days with no production
        const productionDays = (data.daily || []).filter(day => 
          day.totalLbs > 0 || day.totalTops > 0 || day.totalSmalls > 0
        );
        
        if (productionDays.length === 0) {
          throw new Error('No production data available for the last 30 days');
        }

        return {
          daily: productionDays,
          target: data.targets?.totalTops || 66
        };
      } catch (error) {
        console.error('Error fetching data:', error);
        throw error;
      }
    }

    // Linear regression — returns {slope, intercept, startY, endY} for the dataset
    function linearRegression(values) {
      const n = values.length;
      if (n < 2) return null;
      let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
      for (let i = 0; i < n; i++) {
        sumX += i;
        sumY += values[i];
        sumXY += i * values[i];
        sumX2 += i * i;
      }
      const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      const intercept = (sumY - slope * sumX) / n;
      return { slope, intercept, startY: intercept, endY: slope * (n - 1) + intercept };
    }

    // Chart drawing function
    function drawBarChart(canvas, data, options = {}) {
      const ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.scale(dpr, dpr);

      const width = rect.width;
      const height = rect.height;
      const padding = { top: 30, right: 60, bottom: 40, left: 60 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      // Clear canvas
      ctx.clearRect(0, 0, width, height);

      if (!data || data.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '14px var(--font-ui)';
        ctx.textAlign = 'center';
        ctx.fillText('No data available', width / 2, height / 2);
        return;
      }

      // Calculate max value and average
      const values = data.map(d => d.value).filter(v => v != null && !isNaN(v));
      const maxValue = Math.max(...values, options.targetLine || 0);
      const avgValue = values.reduce((a, b) => a + b, 0) / values.length;
      const yMax = maxValue * 1.15; // Add 15% headroom

      // Colors
      const isPrint = window.matchMedia('print').matches;
      const barColor = isPrint ? '#333' : '#668971';
      const targetColor = isPrint ? '#999' : '#dc2626';
      const avgColor = isPrint ? '#666' : '#3b82f6';
      const gridColor = isPrint ? '#ddd' : 'rgba(255, 255, 255, 0.05)';
      const textColor = isPrint ? '#000' : 'rgba(255, 255, 255, 0.7)';

      // Draw grid lines
      ctx.strokeStyle = gridColor;
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i++) {
        const y = padding.top + (chartHeight / 5) * i;
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(padding.left + chartWidth, y);
        ctx.stroke();
      }

      // Draw Y-axis labels
      ctx.fillStyle = textColor;
      ctx.font = '11px var(--font-mono)';
      ctx.textAlign = 'right';
      for (let i = 0; i <= 5; i++) {
        const value = yMax - (yMax / 5) * i;
        const y = padding.top + (chartHeight / 5) * i;
        ctx.fillText(value.toFixed(0), padding.left - 10, y + 4);
      }

      // Draw bars
      const barWidth = chartWidth / data.length * 0.7;
      const barSpacing = chartWidth / data.length;

      data.forEach((item, index) => {
        if (item.value == null || isNaN(item.value)) return;

        const barHeight = (item.value / yMax) * chartHeight;
        const x = padding.left + index * barSpacing + (barSpacing - barWidth) / 2;
        const y = padding.top + chartHeight - barHeight;

        ctx.fillStyle = barColor;
        ctx.fillRect(x, y, barWidth, barHeight);
      });

      // Draw target line if specified
      if (options.targetLine != null) {
        const targetY = padding.top + chartHeight - (options.targetLine / yMax) * chartHeight;
        ctx.strokeStyle = targetColor;
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(padding.left, targetY);
        ctx.lineTo(padding.left + chartWidth, targetY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Target label
        ctx.fillStyle = targetColor;
        ctx.font = 'bold 11px var(--font-mono)';
        ctx.textAlign = 'left';
        ctx.fillText(`Target: ${options.targetLine.toFixed(1)}`, padding.left + chartWidth + 10, targetY + 4);
      }

      // Draw trend line (linear regression)
      const trend = linearRegression(values);
      if (trend) {
        const trendStartY = padding.top + chartHeight - (trend.startY / yMax) * chartHeight;
        const trendEndY = padding.top + chartHeight - (trend.endY / yMax) * chartHeight;
        ctx.strokeStyle = avgColor;
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 4]);
        ctx.beginPath();
        ctx.moveTo(padding.left + barSpacing / 2, trendStartY);
        ctx.lineTo(padding.left + chartWidth - barSpacing / 2, trendEndY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Trend label with direction
        const direction = trend.slope > 0.01 ? '▲' : trend.slope < -0.01 ? '▼' : '—';
        ctx.fillStyle = avgColor;
        ctx.font = 'bold 11px var(--font-mono)';
        ctx.textAlign = 'left';
        ctx.fillText(`${direction} ${avgValue.toFixed(1)} avg`, padding.left + chartWidth + 6, trendEndY + 4);
      }

      // Draw X-axis labels (dates)
      ctx.fillStyle = textColor;
      ctx.font = '10px var(--font-mono)';
      ctx.textAlign = 'center';
      
      // Show every 3rd date to avoid crowding
      data.forEach((item, index) => {
        if (index % 3 === 0 || index === data.length - 1) {
          const x = padding.left + index * barSpacing + barSpacing / 2;
          const dateStr = new Date(item.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
          ctx.fillText(dateStr, x, height - padding.bottom + 20);
        }
      });
    }

    // Grouped bar chart (two series side by side)
    function drawGroupedBarChart(canvas, data, options = {}) {
      const ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();

      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.scale(dpr, dpr);

      const width = rect.width;
      const height = rect.height;
      const padding = { top: 30, right: 80, bottom: 40, left: 60 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      ctx.clearRect(0, 0, width, height);

      if (!data || data.length === 0) return;

      const isPrint = window.matchMedia('print').matches;
      const color1 = isPrint ? '#333' : '#668971';
      const color2 = isPrint ? '#999' : '#e4aa4f';
      const gridColor = isPrint ? '#ddd' : 'rgba(255, 255, 255, 0.05)';
      const textColor = isPrint ? '#000' : 'rgba(255, 255, 255, 0.7)';
      const avg1Color = isPrint ? '#555' : '#668971';
      const avg2Color = isPrint ? '#888' : '#e4aa4f';

      const allVals = data.flatMap(d => [d.value1, d.value2]).filter(v => v != null && !isNaN(v));
      const yMax = Math.max(...allVals) * 1.15;
      const avg1 = data.map(d => d.value1).filter(v => v != null).reduce((a, b) => a + b, 0) / data.filter(d => d.value1 != null).length;
      const avg2 = data.map(d => d.value2).filter(v => v != null).reduce((a, b) => a + b, 0) / data.filter(d => d.value2 != null).length;

      // Grid
      ctx.strokeStyle = gridColor;
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i++) {
        const y = padding.top + (chartHeight / 5) * i;
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(padding.left + chartWidth, y);
        ctx.stroke();
      }

      // Y-axis labels
      ctx.fillStyle = textColor;
      ctx.font = '11px var(--font-mono)';
      ctx.textAlign = 'right';
      for (let i = 0; i <= 5; i++) {
        const value = yMax - (yMax / 5) * i;
        const y = padding.top + (chartHeight / 5) * i;
        ctx.fillText(value.toFixed(0), padding.left - 10, y + 4);
      }

      // Bars
      const groupWidth = chartWidth / data.length;
      const barWidth = groupWidth * 0.35;
      const gap = groupWidth * 0.05;

      data.forEach((item, index) => {
        const groupX = padding.left + index * groupWidth;

        // Bar 1 (Tops)
        if (item.value1 != null && !isNaN(item.value1)) {
          const h = (item.value1 / yMax) * chartHeight;
          ctx.fillStyle = color1;
          ctx.fillRect(groupX + gap, padding.top + chartHeight - h, barWidth, h);
        }

        // Bar 2 (Smalls)
        if (item.value2 != null && !isNaN(item.value2)) {
          const h = (item.value2 / yMax) * chartHeight;
          ctx.fillStyle = color2;
          ctx.fillRect(groupX + barWidth + gap * 2, padding.top + chartHeight - h, barWidth, h);
        }
      });

      // Trend lines (linear regression)
      const vals1 = data.map(d => d.value1).filter(v => v != null);
      const vals2 = data.map(d => d.value2).filter(v => v != null);
      const trend1 = linearRegression(vals1);
      const trend2 = linearRegression(vals2);

      [{ trend: trend1, avg: avg1, color: avg1Color, label: 'Tops' }, { trend: trend2, avg: avg2, color: avg2Color, label: 'Smalls' }].forEach(({ trend, avg, color, label }) => {
        if (!trend) return;
        const startY = padding.top + chartHeight - (trend.startY / yMax) * chartHeight;
        const endY = padding.top + chartHeight - (trend.endY / yMax) * chartHeight;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 4]);
        ctx.beginPath();
        ctx.moveTo(padding.left + groupWidth / 2, startY);
        ctx.lineTo(padding.left + chartWidth - groupWidth / 2, endY);
        ctx.stroke();
        ctx.setLineDash([]);

        const direction = trend.slope > 0.01 ? '▲' : trend.slope < -0.01 ? '▼' : '—';
        ctx.fillStyle = color;
        ctx.font = 'bold 11px var(--font-mono)';
        ctx.textAlign = 'left';
        ctx.fillText(`${direction} ${label}: ${avg.toFixed(1)}`, padding.left + chartWidth + 6, endY + 4);
      });

      // Legend
      ctx.font = '11px var(--font-ui)';
      ctx.textAlign = 'left';
      ctx.fillStyle = color1;
      ctx.fillRect(padding.left, padding.top - 20, 12, 12);
      ctx.fillText('Tops', padding.left + 16, padding.top - 10);
      ctx.fillStyle = color2;
      ctx.fillRect(padding.left + 70, padding.top - 20, 12, 12);
      ctx.fillText('Smalls', padding.left + 86, padding.top - 10);

      // X-axis
      ctx.fillStyle = textColor;
      ctx.font = '10px var(--font-mono)';
      ctx.textAlign = 'center';
      data.forEach((item, index) => {
        if (index % 3 === 0 || index === data.length - 1) {
          const x = padding.left + index * groupWidth + groupWidth / 2;
          const dateStr = new Date(item.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
          ctx.fillText(dateStr, x, height - padding.bottom + 20);
        }
      });
    }

    // Render all charts
    async function renderCharts() {
      try {
        const data = await fetchProductionData();
        
        document.getElementById('loading').style.display = 'none';
        document.getElementById('chartsContainer').style.display = 'block';

        // 1. Target vs Actual
        drawBarChart(
          document.getElementById('targetActualChart'),
          data.daily.map(d => ({ date: d.date, value: d.totalTops })),
          { targetLine: data.target }
        );

        // 2. Units per Operator per Hour
        drawBarChart(
          document.getElementById('operatorChart'),
          data.daily.map(d => ({
            date: d.date,
            value: d.operatorHours > 0 ? d.totalLbs / d.operatorHours : 0
          }))
        );

        // 3. Units per Trimmer per Hour
        drawBarChart(
          document.getElementById('trimmerChart'),
          data.daily.map(d => ({
            date: d.date,
            value: d.trimmerHours > 0 ? d.totalLbs / d.trimmerHours : 0
          }))
        );

        // 4. Tops & Smalls per Day (grouped)
        drawGroupedBarChart(
          document.getElementById('topsSmallsChart'),
          data.daily.map(d => ({ date: d.date, value1: d.totalTops, value2: d.totalSmalls }))
        );

      } catch (error) {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error').style.display = 'block';
        document.getElementById('error').textContent = `Error loading data: ${error.message}`;
      }
    }

    // Redraw charts on window resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(renderCharts, 250);
    });

    // Initial render
    renderCharts();

    // Spinner animation
    const style = document.createElement('style');
    style.textContent = '@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }';
    document.head.appendChild(style);
  </script>
</body>
</html>
