// =====================================================
// SOP Manager - Code.gs
// Rogue Origin Standard Operating Procedures System
// Google Sheets Backend + Anthropic API Proxy
// With Server-Side Caching for Performance
// =====================================================

// Configuration
const SOP_SPREADSHEET_ID = '1iCIObV6YwAdNq0YSjFqJdf7V1HTaQEiJhBWv8M43kmQ';
const SOP_SHEET_NAME = 'SOPs';
const STEPS_SHEET_NAME = 'SOP_Steps';
const REQUESTS_SHEET_NAME = 'SOP_Requests';
const SETTINGS_SHEET_NAME = 'SOP_Settings';
const CACHE_DURATION = 300; // 5 minutes in seconds

// =====================================================
// Cache Helpers
// =====================================================

function getCache() {
  return CacheService.getScriptCache();
}

function getCachedData(key) {
  const cache = getCache();
  const cached = cache.get(key);
  if (cached) {
    try {
      return JSON.parse(cached);
    } catch (e) {
      return null;
    }
  }
  return null;
}

function setCachedData(key, data) {
  const cache = getCache();
  try {
    cache.put(key, JSON.stringify(data), CACHE_DURATION);
  } catch (e) {
    // Cache might fail for large data, that's okay
    console.log('Cache write failed:', e);
  }
}

function invalidateCache() {
  const cache = getCache();
  cache.removeAll(['sops_data', 'requests_data', 'settings_data', 'last_modified']);
  // Update last modified timestamp
  cache.put('last_modified', new Date().toISOString(), 86400); // 24 hours
}

function getLastModified() {
  const cache = getCache();
  return cache.get('last_modified') || new Date().toISOString();
}

// =====================================================
// Web App Entry Points
// =====================================================

function doGet(e) {
  const action = e.parameter.action;
  const clientLastSync = e.parameter.lastSync; // Client sends their last sync time
  let output;
  
  try {
    switch(action) {
      case 'getSOPs':
        output = getAllSOPsCached();
        break;
      case 'getSOP':
        output = getSOP(e.parameter.id);
        break;
      case 'getRequests':
        output = getAllRequestsCached();
        break;
      case 'getSettings':
        output = getSettingsCached();
        break;
      case 'checkSync':
        // Quick endpoint - just returns if client needs to refresh
        const serverLastMod = getLastModified();
        const needsSync = !clientLastSync || new Date(serverLastMod) > new Date(clientLastSync);
        output = { 
          success: true, 
          needsSync: needsSync, 
          serverTime: serverLastMod 
        };
        break;
      case 'getAllData':
        // Single call to get everything - more efficient for initial load
        output = {
          success: true,
          sops: getAllSOPsCached().data || [],
          requests: getAllRequestsCached().data || [],
          settings: getSettingsCached().data || {},
          lastModified: getLastModified()
        };
        break;
      case 'test':
        output = { success: true, message: 'SOP Manager API is running', timestamp: new Date().toISOString() };
        break;
      default:
        // Serve the web app
        const template = HtmlService.createTemplateFromFile('Index');
        return template.evaluate()
          .setTitle('SOP Manager - Rogue Origin')
          .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
          .addMetaTag('viewport', 'width=device-width, initial-scale=1');
    }
  } catch (error) {
    output = { success: false, error: error.message };
  }
  
  return ContentService
    .createTextOutput(JSON.stringify(output))
    .setMimeType(ContentService.MimeType.JSON);
}

function doPost(e) {
  let output;
  
  try {
    const data = JSON.parse(e.postData.contents);
    const action = data.action;
    
    // Handle Anthropic API proxy requests
    if (action === 'anthropic' && data.body) {
      return handleAnthropicRequest(data);
    }
    
    // Handle SOP CRUD operations - invalidate cache on any write
    switch(action) {
      case 'createSOP':
        output = createSOP(data.sop);
        if (output.success) invalidateCache();
        break;
      case 'updateSOP':
        output = updateSOP(data.sop);
        if (output.success) invalidateCache();
        break;
      case 'deleteSOP':
        output = deleteSOP(data.id);
        if (output.success) invalidateCache();
        break;
      case 'createRequest':
        output = createRequest(data.request);
        if (output.success) invalidateCache();
        break;
      case 'updateRequest':
        output = updateRequest(data.request);
        if (output.success) invalidateCache();
        break;
      case 'deleteRequest':
        output = deleteRequest(data.id);
        if (output.success) invalidateCache();
        break;
      case 'saveSettings':
        output = saveSettings(data.settings);
        if (output.success) invalidateCache();
        break;
      default:
        output = { success: false, error: 'Unknown action: ' + action };
    }
    
    // Include new lastModified time in response for writes
    if (output.success) {
      output.lastModified = getLastModified();
    }
  } catch (error) {
    output = { success: false, error: error.message };
  }
  
  return ContentService
    .createTextOutput(JSON.stringify(output))
    .setMimeType(ContentService.MimeType.JSON);
}

// =====================================================
// Anthropic API Proxy
// =====================================================

function handleAnthropicRequest(data) {
  try {
    // Get API key from Script Properties (secure server-side storage)
    const apiKey = PropertiesService.getScriptProperties().getProperty('ANTHROPIC_API_KEY');
    
    if (!apiKey) {
      return ContentService
        .createTextOutput(JSON.stringify({ error: 'API key not configured in Script Properties' }))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
    const response = UrlFetchApp.fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01'
      },
      payload: JSON.stringify(data.body),
      muteHttpExceptions: true
    });
    
    return ContentService
      .createTextOutput(response.getContentText())
      .setMimeType(ContentService.MimeType.JSON);
      
  } catch (error) {
    return ContentService
      .createTextOutput(JSON.stringify({ error: error.toString() }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

// =====================================================
// Spreadsheet Setup
// =====================================================

function setupSpreadsheet() {
  const ss = SpreadsheetApp.openById(SOP_SPREADSHEET_ID);
  
  // Create SOPs sheet
  let sopSheet = ss.getSheetByName(SOP_SHEET_NAME);
  if (!sopSheet) {
    sopSheet = ss.insertSheet(SOP_SHEET_NAME);
    sopSheet.appendRow([
      'ID', 'Title', 'Title_ES', 'Department', 'DocNum', 'Revision', 'Status', 
      'Description', 'Desc_ES', 'Tags', 'CreatedAt', 'UpdatedAt'
    ]);
    sopSheet.setFrozenRows(1);
    sopSheet.getRange(1, 1, 1, 12).setFontWeight('bold').setBackground('#668971').setFontColor('#fff');
  }
  
  // Create Steps sheet
  let stepsSheet = ss.getSheetByName(STEPS_SHEET_NAME);
  if (!stepsSheet) {
    stepsSheet = ss.insertSheet(STEPS_SHEET_NAME);
    stepsSheet.appendRow([
      'SOP_ID', 'StepNumber', 'Title', 'Title_ES', 'Description', 'Desc_ES',
      'ImageURL', 'SafetyFlag', 'QualityFlag'
    ]);
    stepsSheet.setFrozenRows(1);
    stepsSheet.getRange(1, 1, 1, 9).setFontWeight('bold').setBackground('#668971').setFontColor('#fff');
  }
  
  // Create Requests sheet
  let requestsSheet = ss.getSheetByName(REQUESTS_SHEET_NAME);
  if (!requestsSheet) {
    requestsSheet = ss.insertSheet(REQUESTS_SHEET_NAME);
    requestsSheet.appendRow([
      'ID', 'Title', 'Department', 'Priority', 'Assignee', 'DueDate',
      'Notes', 'Completed', 'CompletedAt', 'CreatedAt', 'SOPId'
    ]);
    requestsSheet.setFrozenRows(1);
    requestsSheet.getRange(1, 1, 1, 11).setFontWeight('bold').setBackground('#668971').setFontColor('#fff');
  }
  
  // Create Settings sheet
  let settingsSheet = ss.getSheetByName(SETTINGS_SHEET_NAME);
  if (!settingsSheet) {
    settingsSheet = ss.insertSheet(SETTINGS_SHEET_NAME);
    settingsSheet.appendRow(['Key', 'Value']);
    settingsSheet.appendRow(['departments', JSON.stringify([
      {name:'Production',icon:'ph-factory'},
      {name:'Packaging',icon:'ph-package'},
      {name:'Quality',icon:'ph-seal-check'},
      {name:'Maintenance',icon:'ph-wrench'}
    ])]);
    settingsSheet.appendRow(['tags', JSON.stringify([
      {name:'safety',color:'danger'},
      {name:'quality',color:'green'},
      {name:'critical',color:'gold'}
    ])]);
    settingsSheet.setFrozenRows(1);
    settingsSheet.getRange(1, 1, 1, 2).setFontWeight('bold').setBackground('#668971').setFontColor('#fff');
  }
  
  return { success: true, message: 'Spreadsheet setup complete' };
}

// =====================================================
// Cached Data Functions
// =====================================================

function getAllSOPsCached() {
  // Try cache first
  const cached = getCachedData('sops_data');
  if (cached) {
    return cached;
  }
  
  // Cache miss - fetch from sheet
  const result = getAllSOPs();
  if (result.success) {
    setCachedData('sops_data', result);
  }
  return result;
}

function getAllRequestsCached() {
  const cached = getCachedData('requests_data');
  if (cached) {
    return cached;
  }
  
  const result = getAllRequests();
  if (result.success) {
    setCachedData('requests_data', result);
  }
  return result;
}

function getSettingsCached() {
  const cached = getCachedData('settings_data');
  if (cached) {
    return cached;
  }
  
  const result = getSettings();
  if (result.success) {
    setCachedData('settings_data', result);
  }
  return result;
}

// =====================================================
// SOP CRUD Operations
// =====================================================

function getAllSOPs() {
  try {
    const ss = SpreadsheetApp.openById(SOP_SPREADSHEET_ID);
    const sopSheet = ss.getSheetByName(SOP_SHEET_NAME);
    const stepsSheet = ss.getSheetByName(STEPS_SHEET_NAME);
    
    if (!sopSheet) {
      return { success: true, data: [] };
    }
    
    // Get all SOPs
    const sopData = sopSheet.getDataRange().getValues();
    if (sopData.length <= 1) {
      return { success: true, data: [] };
    }
    
    const sopHeaders = sopData.shift();
    
    // Get all steps
    let allSteps = [];
    if (stepsSheet) {
      const stepsData = stepsSheet.getDataRange().getValues();
      if (stepsData.length > 1) {
        stepsData.shift(); // Remove header
        allSteps = stepsData.map(row => ({
          sopId: row[0],
          stepNumber: row[1],
          title: row[2],
          title_es: row[3],
          description: row[4],
          desc_es: row[5],
          image: row[6],
          safety: row[7] === true || row[7] === 'TRUE',
          quality: row[8] === true || row[8] === 'TRUE'
        }));
      }
    }
    
    // Build SOP objects with steps
    const sops = sopData.map(row => {
      const sopId = row[0];
      const sopSteps = allSteps
        .filter(s => s.sopId == sopId)
        .sort((a, b) => a.stepNumber - b.stepNumber)
        .map(s => ({
          title: s.title,
          title_es: s.title_es,
          description: s.description,
          desc_es: s.desc_es,
          image: s.image,
          safety: s.safety,
          quality: s.quality
        }));
      
      return {
        id: sopId,
        title: row[1],
        title_es: row[2],
        dept: row[3],
        docNum: row[4],
        revision: row[5],
        status: row[6],
        description: row[7],
        desc_es: row[8],
        tags: row[9] ? row[9].split(',').map(t => t.trim()).filter(t => t) : [],
        createdAt: row[10],
        updatedAt: row[11],
        steps: sopSteps
      };
    });
    
    return { success: true, data: sops };
    
  } catch (error) {
    console.error('getAllSOPs error:', error);
    return { success: false, error: error.message };
  }
}

function getSOP(sopId) {
  try {
    const result = getAllSOPs();
    if (!result.success) return result;
    
    const sop = result.data.find(s => s.id == sopId);
    if (!sop) {
      return { success: false, error: 'SOP not found' };
    }
    
    return { success: true, data: sop };
    
  } catch (error) {
    return { success: false, error: error.message };
  }
}

function createSOP(sopData) {
  try {
    const ss = SpreadsheetApp.openById(SOP_SPREADSHEET_ID);
    let sopSheet = ss.getSheetByName(SOP_SHEET_NAME);
    let stepsSheet = ss.getSheetByName(STEPS_SHEET_NAME);
    
    // Auto-setup if sheets don't exist
    if (!sopSheet || !stepsSheet) {
      setupSpreadsheet();
      sopSheet = ss.getSheetByName(SOP_SHEET_NAME);
      stepsSheet = ss.getSheetByName(STEPS_SHEET_NAME);
    }
    
    const now = new Date().toISOString().split('T')[0];
    const sopId = Date.now();
    
    // Generate doc number if not provided
    const docNum = sopData.docNum || ('SOP-' + String(sopSheet.getLastRow()).padStart(3, '0'));
    
    // Add SOP record
    sopSheet.appendRow([
      sopId,
      sopData.title || '',
      sopData.title_es || '',
      sopData.dept || '',
      docNum,
      sopData.revision || '1.0',
      sopData.status || 'draft',
      sopData.description || '',
      sopData.desc_es || '',
      (sopData.tags || []).join(','),
      now,
      now
    ]);
    
    // Add steps
    if (sopData.steps && sopData.steps.length > 0) {
      const stepRows = sopData.steps.map((step, i) => [
        sopId,
        i + 1,
        step.title || '',
        step.title_es || '',
        step.description || '',
        step.desc_es || '',
        step.image || '',
        step.safety || false,
        step.quality || false
      ]);
      
      if (stepRows.length > 0) {
        stepsSheet.getRange(stepsSheet.getLastRow() + 1, 1, stepRows.length, 9).setValues(stepRows);
      }
    }
    
    return { success: true, id: sopId, message: 'SOP created' };
    
  } catch (error) {
    console.error('createSOP error:', error);
    return { success: false, error: error.message };
  }
}

function updateSOP(sopData) {
  try {
    const ss = SpreadsheetApp.openById(SOP_SPREADSHEET_ID);
    const sopSheet = ss.getSheetByName(SOP_SHEET_NAME);
    const stepsSheet = ss.getSheetByName(STEPS_SHEET_NAME);
    
    if (!sopSheet) {
      return { success: false, error: 'SOPs sheet not found' };
    }
    
    const now = new Date().toISOString().split('T')[0];
    const sopId = sopData.id;
    
    // Find the SOP row
    const data = sopSheet.getDataRange().getValues();
    let rowIndex = -1;
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] == sopId) {
        rowIndex = i + 1;
        break;
      }
    }
    
    if (rowIndex === -1) {
      return { success: false, error: 'SOP not found' };
    }
    
    // Update SOP record (preserve createdAt)
    sopSheet.getRange(rowIndex, 2, 1, 10).setValues([[
      sopData.title || '',
      sopData.title_es || '',
      sopData.dept || '',
      sopData.docNum || '',
      sopData.revision || '1.0',
      sopData.status || 'draft',
      sopData.description || '',
      sopData.desc_es || '',
      (sopData.tags || []).join(','),
      now
    ]]);
    
    // Delete old steps
    if (stepsSheet) {
      const stepsData = stepsSheet.getDataRange().getValues();
      for (let i = stepsData.length - 1; i > 0; i--) {
        if (stepsData[i][0] == sopId) {
          stepsSheet.deleteRow(i + 1);
        }
      }
      
      // Add new steps
      if (sopData.steps && sopData.steps.length > 0) {
        const stepRows = sopData.steps.map((step, i) => [
          sopId,
          i + 1,
          step.title || '',
          step.title_es || '',
          step.description || '',
          step.desc_es || '',
          step.image || '',
          step.safety || false,
          step.quality || false
        ]);
        
        if (stepRows.length > 0) {
          stepsSheet.getRange(stepsSheet.getLastRow() + 1, 1, stepRows.length, 9).setValues(stepRows);
        }
      }
    }
    
    return { success: true, message: 'SOP updated' };
    
  } catch (error) {
    console.error('updateSOP error:', error);
    return { success: false, error: error.message };
  }
}

function deleteSOP(sopId) {
  try {
    const ss = SpreadsheetApp.openById(SOP_SPREADSHEET_ID);
    const sopSheet = ss.getSheetByName(SOP_SHEET_NAME);
    const stepsSheet = ss.getSheetByName(STEPS_SHEET_NAME);
    
    // Delete SOP row
    if (sopSheet) {
      const sopData = sopSheet.getDataRange().getValues();
      for (let i = sopData.length - 1; i > 0; i--) {
        if (sopData[i][0] == sopId) {
          sopSheet.deleteRow(i + 1);
          break;
        }
      }
    }
    
    // Delete associated steps
    if (stepsSheet) {
      const stepsData = stepsSheet.getDataRange().getValues();
      for (let i = stepsData.length - 1; i > 0; i--) {
        if (stepsData[i][0] == sopId) {
          stepsSheet.deleteRow(i + 1);
        }
      }
    }
    
    return { success: true, message: 'SOP deleted' };
    
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// =====================================================
// Request CRUD Operations
// =====================================================

function getAllRequests() {
  try {
    const ss = SpreadsheetApp.openById(SOP_SPREADSHEET_ID);
    const sheet = ss.getSheetByName(REQUESTS_SHEET_NAME);
    
    if (!sheet) {
      return { success: true, data: [] };
    }
    
    const data = sheet.getDataRange().getValues();
    if (data.length <= 1) {
      return { success: true, data: [] };
    }
    
    data.shift(); // Remove header
    
    const requests = data.map(row => ({
      id: row[0],
      title: row[1],
      dept: row[2],
      priority: row[3],
      assignee: row[4],
      dueDate: row[5],
      notes: row[6],
      completed: row[7] === true || row[7] === 'TRUE',
      completedAt: row[8],
      createdAt: row[9],
      sopId: row[10]
    }));
    
    return { success: true, data: requests };
    
  } catch (error) {
    return { success: false, error: error.message };
  }
}

function createRequest(reqData) {
  try {
    const ss = SpreadsheetApp.openById(SOP_SPREADSHEET_ID);
    let sheet = ss.getSheetByName(REQUESTS_SHEET_NAME);
    
    if (!sheet) {
      setupSpreadsheet();
      sheet = ss.getSheetByName(REQUESTS_SHEET_NAME);
    }
    
    const now = new Date().toISOString().split('T')[0];
    const reqId = Date.now();
    
    sheet.appendRow([
      reqId,
      reqData.title || '',
      reqData.dept || '',
      reqData.priority || 'medium',
      reqData.assignee || '',
      reqData.dueDate || '',
      reqData.notes || '',
      false,
      '',
      now,
      ''
    ]);
    
    return { success: true, id: reqId, message: 'Request created' };
    
  } catch (error) {
    return { success: false, error: error.message };
  }
}

function updateRequest(reqData) {
  try {
    const ss = SpreadsheetApp.openById(SOP_SPREADSHEET_ID);
    const sheet = ss.getSheetByName(REQUESTS_SHEET_NAME);
    
    if (!sheet) {
      return { success: false, error: 'Requests sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    let rowIndex = -1;
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] == reqData.id) {
        rowIndex = i + 1;
        break;
      }
    }
    
    if (rowIndex === -1) {
      return { success: false, error: 'Request not found' };
    }
    
    const now = new Date().toISOString().split('T')[0];
    
    sheet.getRange(rowIndex, 2, 1, 10).setValues([[
      reqData.title || '',
      reqData.dept || '',
      reqData.priority || 'medium',
      reqData.assignee || '',
      reqData.dueDate || '',
      reqData.notes || '',
      reqData.completed || false,
      reqData.completed ? now : '',
      data[rowIndex - 1][9], // Preserve createdAt
      reqData.sopId || ''
    ]]);
    
    return { success: true, message: 'Request updated' };
    
  } catch (error) {
    return { success: false, error: error.message };
  }
}

function deleteRequest(reqId) {
  try {
    const ss = SpreadsheetApp.openById(SOP_SPREADSHEET_ID);
    const sheet = ss.getSheetByName(REQUESTS_SHEET_NAME);
    
    if (!sheet) {
      return { success: false, error: 'Requests sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    for (let i = data.length - 1; i > 0; i--) {
      if (data[i][0] == reqId) {
        sheet.deleteRow(i + 1);
        break;
      }
    }
    
    return { success: true, message: 'Request deleted' };
    
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// =====================================================
// Settings
// =====================================================

function getSettings() {
  try {
    const ss = SpreadsheetApp.openById(SOP_SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SETTINGS_SHEET_NAME);
    
    if (!sheet) {
      // Return defaults
      return {
        success: true,
        data: {
          departments: [
            {name:'Production',icon:'ph-factory'},
            {name:'Packaging',icon:'ph-package'},
            {name:'Quality',icon:'ph-seal-check'},
            {name:'Maintenance',icon:'ph-wrench'}
          ],
          tags: [
            {name:'safety',color:'danger'},
            {name:'quality',color:'green'},
            {name:'critical',color:'gold'}
          ]
        }
      };
    }
    
    const data = sheet.getDataRange().getValues();
    const settings = {};
    
    for (let i = 1; i < data.length; i++) {
      try {
        settings[data[i][0]] = JSON.parse(data[i][1]);
      } catch (e) {
        settings[data[i][0]] = data[i][1];
      }
    }
    
    return { success: true, data: settings };
    
  } catch (error) {
    return { success: false, error: error.message };
  }
}

function saveSettings(settingsData) {
  try {
    const ss = SpreadsheetApp.openById(SOP_SPREADSHEET_ID);
    let sheet = ss.getSheetByName(SETTINGS_SHEET_NAME);
    
    if (!sheet) {
      setupSpreadsheet();
      sheet = ss.getSheetByName(SETTINGS_SHEET_NAME);
    }
    
    // Clear existing data (except header)
    const lastRow = sheet.getLastRow();
    if (lastRow > 1) {
      sheet.deleteRows(2, lastRow - 1);
    }
    
    // Add settings rows
    if (settingsData.departments) {
      sheet.appendRow(['departments', JSON.stringify(settingsData.departments)]);
    }
    if (settingsData.tags) {
      sheet.appendRow(['tags', JSON.stringify(settingsData.tags)]);
    }
    
    return { success: true, message: 'Settings saved' };
    
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// =====================================================
// Image Storage (Google Drive)
// =====================================================

function saveImageToDrive(base64Data, filename) {
  try {
    const base64Content = base64Data.replace(/^data:image\/\w+;base64,/, '');
    const blob = Utilities.newBlob(Utilities.base64Decode(base64Content), 'image/png', filename);
    
    let folder;
    const folders = DriveApp.getFoldersByName('SOP_Images');
    if (folders.hasNext()) {
      folder = folders.next();
    } else {
      folder = DriveApp.createFolder('SOP_Images');
    }
    
    const file = folder.createFile(blob);
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    
    return 'https://drive.google.com/uc?export=view&id=' + file.getId();
    
  } catch (error) {
    console.error('saveImageToDrive error:', error);
    return null;
  }
}

// =====================================================
// Include Helper (for Apps Script serving)
// =====================================================

function include(filename) {
  return HtmlService.createHtmlOutputFromFile(filename).getContent();
}

// =====================================================
// Test Functions
// =====================================================

function testSetup() {
  const result = setupSpreadsheet();
  console.log('Setup result:', result);
}

function testGetAllSOPs() {
  const result = getAllSOPs();
  console.log('Get all SOPs:', JSON.stringify(result, null, 2));
}

function testGetRequests() {
  const result = getAllRequests();
  console.log('Get requests:', JSON.stringify(result, null, 2));
}

function testGetSettings() {
  const result = getSettings();
  console.log('Get settings:', JSON.stringify(result, null, 2));
}

function testAnthropicConnection() {
  const apiKey = PropertiesService.getScriptProperties().getProperty('ANTHROPIC_API_KEY');
  
  if (!apiKey) {
    console.log('No API key found in Script Properties');
    return;
  }
  
  try {
    const response = UrlFetchApp.fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01'
      },
      payload: JSON.stringify({
        model: 'claude-3-5-haiku-20241022',
        max_tokens: 10,
        messages: [{ role: 'user', content: 'Say OK' }]
      }),
      muteHttpExceptions: true
    });
    
    console.log('Anthropic API response:', response.getContentText());
  } catch (error) {
    console.log('Error:', error.toString());
  }
}
